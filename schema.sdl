directive @oneOf on INPUT_OBJECT

input AccountOwnerFilter @oneOf {
	role: StringFilter
	address: StringFilter
}


type Contract {
	"""
	WARNING: This information should not normally be queried as it is rather slow.
	It can be used to validate the marlowe-rs contract simulation state-machine implementation
	such that each redeemer is applied to the previous datum, validating the resulting output datum
	which should always match the actual datum as seen on chain. If at any point these differ,
	we know there is a bug in marlowe-rs. This property will return null if there are no issues detected.
	Note that this is only for testing on PREPROD.
	"""
	marloweRsTest: String!
	"""
	This property will provide a human readable description of the contracts current status.
	"""
	description: String!
	"""
	true if the contract expects a notification to be made, and we can tell that
	any notification sent at this time will cause the notification to be true.
	"""
	expectedNotificationIsTrue: Boolean
	"""
	The datum of the last observed utxo in the contract chain
	"""
	datumJson: String
	"""
	Script hash of the marlowe payout validator script used for this contract
	"""
	payoutValidatorHash: String
	"""
	The minimum time at which point this contract will be possible to transition to a possible next stage.
	"""
	minTime: Int
	"""
	Current contract definition in DSL format
	"""
	contractDsl: String
	"""
	Current contract definition in JSON format
	"""
	contractJson: String
	"""
	List of all remaining contract participants.
	"""
	remainingParticipants: [String!]!
	"""
	List of all known contract participants.
	"""
	participants: [String!]!
	"""
	JSON serialized representation of the current contract state.
	"""
	contractStateJson: String
	hasTimedOut: Boolean!
	continuations: JSONObject!
	"""
	Available only if the contract is in a state at which it may time out.
	This will be a negative value if the contract has already timed out.
	BUG: Generic(\"This contract is not fully initialized. There is an invalid case in a When contract.\"
	BUG INFO: This happens when there are merkleized cases - bug created in marlowe-rs.
	"""
	nextTimeOut: Float
	"""
	Base58 encoded version of block_num,tx_num,utxo_index. Used as cursor for marlowe-indexer.
	"""
	shortId: String!
	"""
	The hash of the transaction that initiated the contract utxo chain
	"""
	id: String!
	"""
	The marlowe validator hash where the contracts utxo chain lives.
	"""
	validatorHash: String!
	"""
	All observed states that this contract has been in
	"""
	transitions(filter: TransitionFilter): [MarloweTransition!]!
}

type ContractConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [ContractEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [Contract!]!
	totalIndexedContracts: Int!
	totalNumberOfContractsMatchingCurrentFilter: Int!
	totalNumberOfPagesUsingCurrentFilter: Int!
	pageSizeUsedForThisResultSet: Int!
	totalContractsInRequestedRange: Int!
	timeTakenMs: Float!
	currentPage: Float!
	log: [String!]!
}

"""
An edge in a connection.
"""
type ContractEdge {
	"""
	The item at the end of the edge
	"""
	node: Contract!
	"""
	A cursor for use in pagination
	"""
	cursor: String!
}

input ContractsFilter {
	id: StringFilter
	"""
	Custom cursor id used by marlowe-indexer, based on block,tx and utxo position on chain, converted to base58.
	"""
	shortId: StringFilter
	hasIssues: Boolean
	accountState: LockedAmountFilter
	isClosed: Boolean
	meta: StringFilter
	validatorHash: StringFilter
	marloweRsStatus: StringFilter
	"""
	Filter by number of bound values in current state
	"""
	boundValues: NumFilter
	datum: StringFilter
}




"""
A scalar that can represent any JSON Object value.
"""
scalar JSONObject

input LockedAmountFilter {
	amount: NumFilter
	currencySymbol: StringFilter
	tokenName: StringFilter
	accountOwner: AccountOwnerFilter
	numberOfAccounts: NumFilter
}

type LockedAmountsResult {
	amount: Float!
	currencySymbol: String!
	tokenName: String!
	accountOwnerRole: String
	accountOwnerAddr: String
}

type MarloweTransition {
	meta: String
	datumJson: String
	inputsJson: String
	inputs: [String!]
	txId: String!
	utxoIndex: Float
	end: Boolean!
	slot: Float!
	blockHash: String!
	blockNum: Float!
	invalid: Boolean!
	issues: [String!]!
	marloweScanStatus: String
	lockedAmounts: [LockedAmountsResult!]
}

input NumFilter @oneOf {
	eq: Float
	gt: Float
	lt: Float
	lte: Float
	gte: Float
}

"""
Information about pagination in a connection
"""
type PageInfo {
	"""
	When paginating backwards, are there more items?
	"""
	hasPreviousPage: Boolean!
	"""
	When paginating forwards, are there more items?
	"""
	hasNextPage: Boolean!
	"""
	When paginating backwards, the cursor to continue.
	"""
	startCursor: String
	"""
	When paginating forwards, the cursor to continue.
	"""
	endCursor: String
}

input Pagination {
	after: String
	before: String
	first: Int
	last: Int
	pageSize: Int
	page: Float
}

type PerfStats {
	"""
	calculated using a sliding window of 60 seconds
	"""
	blocksIndexedPerSecond: Int!
}

type QueryRoot {
	stats: String!
	contracts(filter: ContractsFilter, pagination: Pagination): ContractConnection!
	currentBlock: String
}


input StringFilter @oneOf {
	eq: String
	neq: String
	contains: String
	notContains: String
}

type SubscriptionRoot {
	indexerPerfStats: PerfStats!
	interval: Int!
}

input TransitionFilter {
	"""
	Only show the most recent transition
	"""
	last: Boolean
	end: Boolean
	issues: Boolean
	txId: String
	slot: Float
	blockHash: String
	blockNum: Float
	marloweScanStatus: String
	issuesMatch: String
}

schema {
	query: QueryRoot
	subscription: SubscriptionRoot
}
